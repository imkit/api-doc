
# Client Info: publicKey property

Client info must have publicKey property. The RSA key pair is generated by client or by customer server. The client should keep its private key, and set public key to the client info for other clients to access.

https://github.com/FUNTEKco/chat-server-document/wiki/Model#Client

```javascript
{
  "_id": "sss",
  ...
  "publicKey": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsc4mdvgkjr8bFfDYpGNUdM7TqxIaTgYoYShreT+LqS/DlqhreidAaalhx048BKT2HcUZ+0U0Gh9hxA4vmaPvwUXeK2IFv93lcZf/uXB/WXLH0bBhooFUK38sDVdBCjsRvJalpGjfAxFCYMmIPLsttJawCpg3WPjxzNg2YGE1H2M2OwD1VQoRuUPD9OUkpQa7b4CO5WDdRmfqq3k9vPvcE8MocGQoofFCh7TJ8ohM+bHXi5kpC57zjidoD2uvZopuYgAC+0adlW8wpj2vS04oAEJ4wJ1a7KUSHgeZM6rpL+1Xntdi5UWTRn4ATKelfruLnYkwM9DpZ3SlG7RRhVviSwIDAQAB"
}
```


# Room: encrypted property

For a room has property encrypted set to true, client SDK would send encrypted message to the room, and chat server would save encrypted messages into database.

```javascript
{
  "_id": "58871b877390be11d5f1ab30",
  ...
  "encrypted": true
}
```

https://github.com/FUNTEKco/chat-server-document/wiki/Model#Room

# Message: encryption format

To send a encrypted message to a room, please check

https://github.com/FUNTEKco/chat-server-document/wiki/%5BMessage%5D-Format#user-content-encrypted-message

### Encrypted Message

The message filed should formatted as:
```
MEMBER_ID:IV:KEY|...|AES-Encrypted-Message
```

**IV** = randomly generated AES IV, should be encrypted by room member's public rsa key and encoded by base64.

**Key** = randomly generated AES KEY, should be encrypted by room member's public rsa key and encoded by base64.

That is
```
{Base64 Encoded MEMBER_ID}:{Base64 Encoded AES IV}:{Base64 Encoded AES KEY}[|{Base64 Encoded MEMBER_ID}:{Base64 Encoded AES IV}:{Base64 Encoded AES KEY}:]|{Base64 Encoded AES-Encrypted Message}

=
Base64(CLIENT_1):Base64(Encrypt(AES_IV, CLIENT_1_PUBLIC_KEY)):Base64(Encrypt(AES_KEY, CLIENT_1_PUBLIC_KEY))|base64(CLIENT_2):Base64(Encrypt(AES_IV, CLIENT_2_PUBLIC_KEY)):Base64(Encrypt(AES_KEY, CLIENT_2_PUBLIC_KEY))|...|AES_ENCRYPTED_MESSAGE

```

RSA Cipher Transformation: **RSA/None/PKCS1Padding**

AES Cipher Transformation: **AES/CBC/PKCS5Padding**

### Message sample

```javascript
{
  "messageType": "encrypted",
  "message": "c3Nz:mIFJcaXk58v2LSakX1FohJNurf8mPy2fzGHAxpBZwVReLz1+3iRfamjfRfk/43mnILH9vaw9Emh9twoMeTyUoaOHTpKL+m/oDD60l0LXLAuFPxe6m6TI+Df7ZBujufNTMomn8P19w7vDfuF0ccOH1dxXyVn3kfX6yMp4b/oIoGoERp62oGQr92gYM1VeJtCxTFanAvfMb76BtSYM5dzEfSOYj0TDdp4Uv/ZQqTqbgu+GReuN+3BkMmZ2YDMrSS9WxZRN9UvpAJ/PePrqFxU6UcTae94A9ntYaOb1Gd24XoaAYcqNLNN/sDDXB8uS4aH86OQGb4WaEpQf6AxjzuxiFQ==:sUXk6iLZBBGBO69GtcbZKfscIBGcQSl2z0D1V4CzHTwDqShjzM5Jheaw29jmjE0w3oC0ZJr0fb8+UZz7K2Lg7rhFZlbjQUgZjbXPipCzoJkulHgJoP1KO1/qR+Jb1S5ALsUrugNbeYJmlZIapiYv2D7iMDpG8vmlGQCZBVukYkw55Nqs2qcs9qvp76gY3Gahrbhc8KRi8V6knm80GpmBspuDuGFBd0k544S2C5aKJpA//c/y/Ik2zEKljsGxTcFb9TdbXBTWTVfGrTYjNc+KoH4k50yO/aIyQRqlC3GewbfsnbnhmcUJguEOr+31mzvBQlqq8NkhZkiSeMqzHhXRFg==|YWFh:jtZYTdT+teVpAKCVKg6uGd+/FPseIaKZM5zeMe84xovY3wGaK8c4LdgNVtPEj0/E6wbZbMsD05fFmjwvydkZca73/P9Mp5GRR5QkE1SzlYupFz/pJimF8G2xc6WcY/Xyn1w0mTzvXE7JP6N/4n49/GF+Fmbne3Fe2G4fsghpeK0SkHKFnig+XA0nWXv/VJKne5sUmARj2Ti7g39mmtNbn1mTx8LoyRIsSZokZbjN5SfoiLBjfnYg2av7umx/CIY6xyzdR3n0s6KaPjKNohf48326B9Tjb9mB3KlVRgoIjbe5GsVoRMUYg2SN1s1qFf2x5OaZ7528GExHd4KehJwNtQ==:pEnpV/c4rR+N9tz6Ntu/4eUpd/Z3d0z5+ZuXBmCzRF3NM7afnXhqSyyy+FEinpMy+3HIDV1hoBS9Xz+bvh/tNZzhuwV/0rPPhPKmR9jGoJ4ke+Jgw/zgGo9+0D2ZJqDg0Z3Zxn0KRypjQu6Wgf5qYtv/3zOx1DPHMhK9poUvm+gY0Bg3zvfmLbf2C5QJoBPd74lxbkvsoNBXjFKc7oG/ARteSHxSc5mocrf69Dcg/pUyDXE/mp1vEDmeWHo+XwHmoGIMoR19ems86wlNtWns/mu9VqvPsfPVd1U2HA7i3Ma0vWFiMEbsK8P5bbajfprsZfG5UJf2P9EW7VOfkDbmlQ==|HqF/6yHme/aBBGpbDShEiotOi6SmJdrw5wrOLhY7rJIY++CTG1VBudhw2x3E+gUTsK2kt5QiTBfOKklQqwt8hw==",
,
  ...
}
```
## Client SDK Implementation Sample

### Sending message
```java
HashMap<String, Object> map;
if (room.isEncrypted()) { // 加密
    map = new HashMap<>();
    map.put("messageType", Message.MESSAGE_TYPE_ENCRYPTED);
    String encrypted = encryptMessage(room, message);
    map.put("message", encrypted);
} else { // 無加密
    map = new Gson().fromJson(message.toString(), HashMap.class);
}
```

### Handle messages from remote
```java
if (message.getType().equalsIgnoreCase(Message.MESSAGE_TYPE_ENCRYPTED)) {
    decryptMessage(message);
}
```

### Encrypt message
```java
    private String encryptMessage(Room room, Message message) throws Exception {
        byte iv[] = AESUtil.generateIV();
        byte key[] = AESUtil.generateKey();
        String plain = message.toString();
        String encryptedMessage = AESUtil.encrypt(iv, key, plain);
        StringBuilder sb = new StringBuilder();
        for (Client member: room.getMembers()) {
            if (TextUtils.isEmpty(member.getPublicKey())) {
                continue;
            }
            String encryptIV = RSAUtil.encryptByPublicKey(iv, member.getPublicKey());
            String encryptKey = RSAUtil.encryptByPublicKey(key, member.getPublicKey());
            String encodedClientId = Base64.encodeToString(member.getId().getBytes(Charset.forName("UTF-8")), Base64.NO_WRAP);
            sb.append(encodedClientId).append(":").append(encryptIV).append(":").append(encryptKey).append("|");
        }
        sb.append(encryptedMessage);
        return sb.toString();
    }
```


### Decrypt message
```java
    private void decryptMessage(Message message) {
        if (currentClient() == null || TextUtils.isEmpty(currentClient().getId())) {
            Log.e(TAG, "null current client or empty current client id");
            return;
        }
        if (privateKey == null) {
            Log.e(TAG, "null private key");
            return;
        }
        try {
            String encryptedList[] = message.getMessage().split("\\|");
            if (encryptedList == null || encryptedList.length == 0) {
                return;
            }
            String encryptedMessage = encryptedList[encryptedList.length - 1];
            byte[] iv = null;
            byte[] key = null;

            String encodedClientId = Base64.encodeToString(currentClient().getId().getBytes(Charset.forName("UTF-8")), Base64.NO_WRAP);
            String myPrefix = encodedClientId + ":";
            for (String encrypted: encryptedList) {
                if (!encrypted.startsWith(myPrefix)) {
                    continue;
                }

                String comps[] = encrypted.split(":");
                if (comps.length != 3) {
                    Log.e(TAG, "unexpected encryption part");
                    continue;
                }

                iv = RSAUtil.decryptByPrivateKey(comps[1], privateKey);
                key = RSAUtil.decryptByPrivateKey(comps[2], privateKey);
                break;
            }
            if (iv == null || key == null) {
                Log.e(TAG, "null iv or key");
                return;
            }
            String plainJson = AESUtil.decrypt(iv, key, encryptedMessage);
            Message plainMessage = Message.fromJSON(plainJson);
            message.setMessage(plainMessage.getMessage());
            message.setReply(plainMessage.getReply());
            message.setExtra(plainMessage.getExtra());
            message.setWidth(plainMessage.getWidth());
            message.setHeight(plainMessage.getHeight());
            message.setOriginUrl(plainMessage.getOriginUrl());
            message.setThumbnailUrl(plainMessage.getThumbnailUrl());
            message.setDuration(plainMessage.getDuration());
            message.setSticker(plainMessage.getTitle());
            message.setType(plainMessage.getType());
        } catch (Exception e) {
            Log.e(TAG, "decryptMessage", e);
        }
        return;
    }
```

```java
public class RSAUtil {
    public static final String TRANSFORMATION = "RSA/None/PKCS1Padding";

    public static String encryptByPublicKey(byte[] data, String publicKey) throws Exception {
        byte[] pkArr = Base64.decode(publicKey, Base64.DEFAULT);
        PublicKey pubKey = getPublicKey(pkArr);
        byte[] encrypted = encryptByPublicKey(data, pubKey);
        return Base64.encodeToString(encrypted, Base64.NO_WRAP);
    }

    public static byte[] encryptByPublicKey(byte[] data, PublicKey pubKey) throws Exception {
        Cipher cp = Cipher.getInstance(TRANSFORMATION);
        cp.init(Cipher.ENCRYPT_MODE, pubKey);
        return cp.doFinal(data);
    }

    public static byte[] decryptByPrivateKey(String encrypted, PrivateKey privateKey) throws Exception {
        byte[] data = Base64.decode(encrypted, Base64.DEFAULT);
        byte[] plain = decryptByPrivateKey(data, privateKey);
        return plain;
    }

    public static byte[] decryptByPrivateKey(byte[] encrypted, PrivateKey privateKey) throws Exception {
        Cipher cp = Cipher.getInstance(TRANSFORMATION);
        cp.init(Cipher.DECRYPT_MODE, privateKey);
        return cp.doFinal(encrypted);
    }
}

```

```java
public class AESUtil {

    private static final String TAG = "AESUtil";

    public static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";

    static byte[] generateIV() {
        return generateRandomBytes(16);
    }

    static byte[] generateKey() {
        return generateRandomBytes(16);
    }

    static byte[] generateRandomBytes(int length) {
        byte[] iv = new byte[length];
        for (int i = 0; i < length; i += 1) {
            iv[i] = (byte)((int)(Math.random() * 256) % 256);
        }
        return iv;
    }

    static String encrypt(byte[] iv, byte[] key, String text) {
        byte[] data = text.getBytes(Charset.forName("UTF-8"));
        byte[] encrypted = encrypt(iv, key, data);
        return Base64.encodeToString(encrypted, Base64.NO_WRAP);
    }

    static byte[] encrypt(byte[] iv, byte[] key, byte[] data) {
        try {
            if (data == null || data.length == 0
                    || key == null || key.length < 16
                    || iv == null || iv.length < 16) {
                throw (new InvalidParameterException());
            }
            AlgorithmParameterSpec mAlgorithmParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec mSecretKeySpec = new SecretKeySpec(key, "AES");
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE,mSecretKeySpec,mAlgorithmParameterSpec);
            return cipher.doFinal(data);
        } catch(Exception e) {
            Log.e(TAG, "encrypt", e);
            return null;
        }
    }

    static String decrypt(byte[] iv,byte[] key, String encrypted) {
        byte[] data = Base64.decode(encrypted, Base64.DEFAULT);
        byte[] plain = decrypt(iv, key, data);
        return new String(plain, Charset.forName("UTF-8"));
    }

    static byte[] decrypt(byte[] iv,byte[] key, byte[] data) {
        try {
            if (data == null || data.length == 0
                    || key == null || key.length < 16
                    || iv == null || iv.length < 16) {
                throw (new InvalidParameterException());
            }
            AlgorithmParameterSpec mAlgorithmParameterSpec = new IvParameterSpec(iv);
            SecretKeySpec mSecretKeySpec = new SecretKeySpec(key, "AES");
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, mAlgorithmParameterSpec);
            return cipher.doFinal(data);
        } catch(Exception e) {
            Log.e(TAG, "encrypt", e);
            return null;
        }
    }
}
```